<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Bot D·ª± ƒêo√°n T√†i X·ªâu - Full M√†n H√¨nh</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.jsdelivr.net/npm/particles.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      height: 100%;
    }

    #gameSelect {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('https://i.postimg.cc/hPHzbKdb/HD-wallpaper-saturn-2-blue-galaxy-planet-ring-sky-space-stars-universe.jpg') no-repeat center center;
      background-size: cover;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    #gameSelect::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(0,40,80,0.3) 0%, rgba(0,0,30,0.7) 100%);
      z-index: -1;
    }

    @keyframes gradientBG {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .gameOptionsContainer {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 700px;
      gap: 15px;
    }

    .gameOption {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      margin: 0;
      padding: 15px 25px;
      background: rgba(0, 20, 40, 0.85);
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s;
      width: 300px;
      box-shadow: 0 4px 20px rgba(0, 150, 255, 0.3);
      backdrop-filter: blur(5px);
      border: 1px solid rgba(0, 255, 255, 0.2);
      position: relative;
      overflow: hidden;
    }

    .gameOption::before {
      content: "";
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(to bottom right, 
        transparent 0%, 
        rgba(0, 255, 255, 0.1) 30%, 
        transparent 60%);
      transform: rotate(30deg);
      transition: all 0.5s;
    }

    .gameOption:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 30px rgba(0, 200, 255, 0.5);
    }

    .gameOption:hover::before {
      left: 100%;
    }

    .gameOption img {
      width: 50px;
      height: 50px;
      margin-right: 15px;
      border-radius: 12px;
      border: 2px solid rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 10px rgba(0, 200, 255, 0.3);
    }

    .gameOption span {
      font-size: 18px;
      font-weight: 600;
      color: #00ffff;
      text-shadow: 0 0 5px rgba(0, 200, 255, 0.7);
    }

    h2 {
      color: #00ffff;
      margin-bottom: 30px;
      font-size: 32px;
      text-align: center;
      text-shadow: 0 0 15px rgba(0, 200, 255, 0.7);
      position: relative;
      padding-bottom: 15px;
    }

    h2::after {
      content: "";
      display: block;
      width: 150px;
      height: 3px;
      background: linear-gradient(90deg, transparent, #00ffff, transparent);
      margin: 15px auto 0;
      border-radius: 3px;
    }

    iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
      display: none;
      z-index: 1;
    }

    #backButton {
      position: fixed;
      top: 15px;
      left: 15px;
      padding: 8px 16px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      z-index: 1001;
      display: none;
      font-weight: bold;
      box-shadow: 0 5px 15px rgba(0, 150, 255, 0.4);
      transition: all 0.3s;
      font-size: 16px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    #backButton:hover {
      background: rgba(0, 0, 0, 0.8);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }

    #robotContainer {
      position: fixed;
      top: 50%;
      left: 30px;
      transform: translateY(-50%);
      display: none;
      align-items: center;
      z-index: 9999;
      cursor: move;
    }

    #robotInner {
      transform: rotate(90deg);
      transform-origin: left center;
      display: flex;
      align-items: center;
    }

   #robotIcon {
  width: 130px;
  height: 130px;
  margin-right: 18px;
  pointer-events: none;
  border: none;
  box-shadow: none;
}

    #robotText {
  background: rgba(42, 42, 42, 0.3);
  color: #ffffff;
  padding: 14px 18px;
  border-radius: 10px;
  font-size: 16px;
  line-height: 1.5;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
  white-space: nowrap;
  max-width: 280px;
  position: relative;
  border: 1px solid rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

    #line1, #line2 {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    strong {
      font-weight: bold;
    }

    #loadingIndicator {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 20, 40, 0.9);
      color: #00ffff;
      padding: 20px 30px;
      border-radius: 12px;
      z-index: 1002;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 30px rgba(0, 150, 255, 0.5);
      font-size: 18px;
      text-align: center;
    }

    .tai {
      color: #00ff88;
      font-weight: bold;
      text-shadow: 0 0 5px rgba(0, 255, 150, 0.7);
    }

    .xiu {
      color: #ff3366;
      font-weight: bold;
      text-shadow: 0 0 5px rgba(255, 50, 100, 0.7);
    }

    /* Game Interface Styles */
    #gameInterface {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('https://i.postimg.cc/hPHzbKdb/HD-wallpaper-saturn-2-blue-galaxy-planet-ring-sky-space-stars-universe.jpg') no-repeat center center;
      background-size: cover;
      z-index: 900;
      overflow: auto;
    }

    #gameInterface::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(0,40,80,0.3) 0%, rgba(0,0,30,0.7) 100%);
      z-index: -1;
    }

    #particles-js {
      position: fixed;
      width: 100%;
      height: 100%;
      z-index: -1;
    }

    .wrapper {
      max-width: 440px;
      margin: 30px auto;
      background: rgba(0, 20, 40, 0.85);
      padding: 25px;
      border-radius: 20px;
      box-shadow: 0 0 30px rgba(0, 200, 255, 0.5);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(0, 255, 255, 0.3);
      position: relative;
      overflow: hidden;
    }

    .wrapper::before {
      content: "";
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(
        to bottom right,
        transparent 0%,
        rgba(0, 255, 255, 0.05) 50%,
        transparent 100%
      );
      transform: rotate(30deg);
      animation: shine 6s infinite linear;
    }

    @keyframes shine {
      0% { transform: rotate(30deg) translate(-30%, -30%); }
      100% { transform: rotate(30deg) translate(30%, 30%); }
    }

    .game-title {
      text-align: center;
      color: #00ffff;
      text-shadow: 0 0 15px #00ffff;
      margin-bottom: 25px;
      font-size: 28px;
      letter-spacing: 1px;
      position: relative;
    }

    .game-title::after {
      content: "";
      display: block;
      width: 150px;
      height: 3px;
      background: linear-gradient(90deg, transparent, #00ffff, transparent);
      margin: 15px auto;
      border-radius: 3px;
    }

    .circle {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: 3px solid #00ffff;
      margin: 20px auto;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 26px;
      font-weight: bold;
      background: rgba(0, 10, 20, 0.7);
      box-shadow: 0 0 30px rgba(0, 200, 255, 0.7), inset 0 0 20px rgba(0, 200, 255, 0.3);
      color: white;
      position: relative;
      overflow: hidden;
      transition: all 0.3s;
    }

    .circle::before {
      content: "";
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(0, 255, 255, 0.1) 0%, transparent 70%);
      animation: rotate 15s linear infinite;
    }

    @keyframes rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .status, .time {
      text-align: center;
      margin-top: 8px;
      font-size: 16px;
      color: #66ccff;
      text-shadow: 0 0 5px rgba(0, 150, 255, 0.5);
    }

    .stats {
      text-align: center;
      margin: 20px 0;
      font-size: 16px;
      background: rgba(0, 60, 120, 0.3);
      border-radius: 12px;
      padding: 12px;
      color: #ffffff;
      border: 1px solid rgba(0, 200, 255, 0.3);
      box-shadow: 0 0 15px rgba(0, 150, 255, 0.3);
      backdrop-filter: blur(5px);
    }

    .history-table {
      width: 100%;
      margin-top: 15px;
      border-collapse: collapse;
      font-size: 14px;
      background: rgba(0, 10, 20, 0.7);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(0, 100, 150, 0.3);
      border: 1px solid rgba(0, 200, 255, 0.2);
    }

    .history-table th, .history-table td {
      padding: 10px;
      border-bottom: 1px solid rgba(0, 100, 150, 0.3);
      text-align: center;
    }

    .history-table th {
      background: rgba(0, 80, 160, 0.7);
      color: #00ccff;
      font-weight: 600;
      text-shadow: 0 0 5px rgba(0, 150, 255, 0.5);
    }

    .tai-cell { 
      background: linear-gradient(135deg, #00aa00, #00ff88);
      color: black; 
      padding: 5px 12px; 
      border-radius: 8px; 
      font-weight: bold;
      box-shadow: 0 0 10px rgba(0, 255, 150, 0.7);
      display: inline-block;
      min-width: 50px;
    }

    .xiu-cell { 
      background: linear-gradient(135deg, #cc0000, #ff3366);
      color: white; 
      padding: 5px 12px; 
      border-radius: 8px; 
      font-weight: bold;
      box-shadow: 0 0 10px rgba(255, 50, 100, 0.7);
      display: inline-block;
      min-width: 50px;
    }

    .win { 
      color: #00ff99; 
      font-weight: bold; 
      text-shadow: 0 0 8px rgba(0, 255, 150, 0.7);
    }

    .lose { 
      color: #ff5555; 
      font-weight: bold; 
      text-shadow: 0 0 8px rgba(255, 80, 80, 0.7);
    }

    .pending { 
      color: #cccccc; 
      font-style: italic; 
    }

    #phienText {
      font-size: 24px;
      color: #ffffff;
      background: rgba(0, 100, 200, 0.6);
      padding: 8px 16px;
      border-radius: 8px;
      text-shadow: 0 0 15px #00ffff;
      font-weight: bold;
      border: 2px solid #00ffff;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }

    #prediction {
      font-size: 28px;
      font-weight: bold;
      color: white;
      text-shadow: 0 0 15px currentColor;
    }

    #extraInfo {
      color: #00ffcc;
      font-size: 16px;
      margin: 15px 0;
      text-shadow: 0 0 5px rgba(0, 200, 200, 0.5);
    }

    #status {
      color: #ffcc00;
      font-weight: bold;
      font-size: 16px;
      text-shadow: 0 0 5px rgba(255, 200, 0, 0.5);
    }

    #clock {
      color: #ffffff;
      font-size: 18px;
      margin: 10px 0;
      text-shadow: 0 0 5px rgba(0, 150, 255, 0.5);
    }

    #winStats {
      color: #ffffff;
      font-weight: bold;
      font-size: 16px;
    }

    #historyBody tr:first-child {
      background: rgba(0, 150, 255, 0.15);
    }

    #historyBody tr:hover {
      background: rgba(0, 100, 200, 0.3);
    }

    /* Animation for game title */
    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }

    .float-1 { animation: float 3s ease-in-out infinite; }
    .float-2 { animation: float 3s ease-in-out infinite 0.3s; }
    .float-3 { animation: float 3s ease-in-out infinite 0.6s; }
    .float-4 { animation: float 3s ease-in-out infinite 0.9s; }
  </style>
</head>
<body>
  <!-- M√†n h√¨nh ch·ªçn game -->
  <div id="gameSelect">
    <h2>üéÆ CH·ªåN N·ªÄN T·∫¢NG CH∆†I GAME</h2>
    <div class="gameOptionsContainer">
      <div class="gameOption" id="sunOption">
        <img src="https://i.postimg.cc/y6wrZ8xx/IMG-7874.jpg" alt="robot.jpg">
        <span>SunWin</span>
      </div>
      <div class="gameOption" id="hitclubOption">
        <img src="https://i.postimg.cc/L6LQBFgT/IMG-7875.jpg" alt="HitClub">
        <span>HitClub</span>
      </div>
      <div class="gameOption" id="b52Option">
        <img src="https://i.postimg.cc/ZKdxtPTK/IMG-7873.jpg" alt="B52">
        <span>B52</span>
      </div>
      <div class="gameOption" id="game789Option">
        <img src="https://raw.githubusercontent.com/csgopravo/csgopravo.github.io/main/789-logo.png" alt="789">
        <span>789 Club</span>
      </div>
    </div>
  </div>

  <!-- C√°c iframe game -->
  <iframe id="sunFrame" src="https://web.sunwin.us/"></iframe>
  <iframe id="game789Frame" src="https://play.789.club"></iframe>

  <!-- N√∫t quay l·∫°i -->
  <button id="backButton">‚Üê QUAY L·∫†I</button>

  <!-- Robot d·ª± ƒëo√°n -->
  <div id="robotContainer">
    <div id="robotInner">
      <img id="robotIcon" src="https://i.postimg.cc/rwkZQhxp/Robot.gif" alt="Robot Icon" />
      <div id="robotText">
        <div id="line1"><strong>Ch·ªù phi√™n m·ªõi</strong></div>
        <div id="line2"></div>
      </div>
    </div>
  </div>

  <!-- Loading indicator -->
  <div id="loadingIndicator">ƒêang k·∫øt n·ªëi...</div>

  <!-- Game Interface (for HitClub and B52) -->
  <div id="gameInterface">
    <div id="particles-js"></div>
    <div class="wrapper">
      <h2 class="game-title">
        <span class="float-1">D·ª∞</span>
        <span class="float-2">ƒêO√ÅN</span>
        <span class="float-3">T√ÄI</span>
        <span class="float-4">X·ªàU</span>
      </h2>
      <div class="status" id="phienText">#------</div>
      <div class="circle" id="prediction">--</div>
      <div class="status" id="extraInfo">--</div>
      <div class="status" id="status">ƒêANG K·∫æT N·ªêI...</div>
      <div class="time" id="clock">--:--:--</div>
      <div class="stats" id="winStats">‚úî Th·∫Øng: 0 | ‚úò Thua: 0</div>

      <table class="history-table">
        <thead>
          <tr>
            <th>Phi√™n</th>
            <th>D·ª± ƒëo√°n</th>
            <th>K·∫øt qu·∫£</th>
            <th>ƒê√°nh gi√°</th>
            <th>Th·ªùi gian</th>
          </tr>
        </thead>
        <tbody id="historyBody">
        </tbody>
      </table>
    </div>
  </div>

  <audio id="soundWin" src="https://freesound.org/data/previews/341/341695_5260877-lq.mp3"></audio>
  <audio id="soundLose" src="https://freesound.org/data/previews/109/109662_945474-lq.mp3"></audio>

  <script>
    // DOM Elements
    const gameSelect = document.getElementById("gameSelect");
    const sunOption = document.getElementById("sunOption");
    const sunFrame = document.getElementById("sunFrame");
    const game789Frame = document.getElementById("game789Frame");
    const backButton = document.getElementById("backButton");
    const robot = document.getElementById("robotContainer");
    const line1 = document.getElementById("line1");
    const line2 = document.getElementById("line2");
    const loadingIndicator = document.getElementById("loadingIndicator");
    const gameInterface = document.getElementById("gameInterface");
    const phienText = document.getElementById("phienText");
    const predictionCircle = document.getElementById("prediction");
    const extraInfo = document.getElementById("extraInfo");
    const statusText = document.getElementById("status");
    const clockText = document.getElementById("clock");
    const winStats = document.getElementById("winStats");
    const historyBody = document.getElementById("historyBody");
    const soundWin = document.getElementById("soundWin");
    const soundLose = document.getElementById("soundLose");

    let currentGame = null;
    let fetchInterval = null;
    let isFetching = false;
    let currentProxyIndex = 0;
    let retryCount = 0;
    let winCount = 0;
    let loseCount = 0;
    let historyData = [];
    let lastProcessedSession = null;
    let lastResultData = null;
    let currentSessionData = null;
    let isAnalyzing = false;
    let analysisTimeout = null;
    let pendingResults = {};

    // API endpoints
    const SUNWIN_API = "https://saobody-lopq.onrender.com/api/taixiu/sunwin";
    const HITCLUB_API = "https://chuaphai-laanh.onrender.com/data";
    const B52_API = "https://xaoko-19272.onrender.com/taixiu";
    const GAME789_API = "https://tailkoa-762.onrender.com/taixiu";

    // Event listeners  
    sunOption.addEventListener("click", () => selectGame("sun"));
    document.getElementById("hitclubOption").addEventListener("click", () => selectGame("hitclub"));
    document.getElementById("b52Option").addEventListener("click", () => selectGame("b52"));
    document.getElementById("game789Option").addEventListener("click", () => selectGame("game789"));
    backButton.addEventListener("click", deselectGame);

    // Main functions
    function selectGame(game) {
      currentGame = game;
      gameSelect.style.display = "none";
      backButton.style.display = "block";
      
      // Reset stats
      winCount = 0;
      loseCount = 0;
      historyData = [];
      lastProcessedSession = null;
      lastResultData = null;
      pendingResults = {};
      updateStats();
      historyBody.innerHTML = "";

      if (game === "sun") {
        sunFrame.style.display = "block";
        robot.style.display = "flex";
        startFetching(SUNWIN_API, processSunData);
      } else if (game === "game789") {
        game789Frame.style.display = "block";
        robot.style.display = "flex";
        startFetching(GAME789_API, process789Data);
      } else if (game === "hitclub" || game === "b52") {
        gameInterface.style.display = "block";
        const gameTitle = document.querySelector(".game-title");
        if (gameTitle) {
          gameTitle.innerHTML = game === "hitclub" ? 
            '<span class="float-1">D·ª∞</span> <span class="float-2">ƒêO√ÅN</span> <span class="float-3">HITCLUB</span>' :
            '<span class="float-1">D·ª∞</span> <span class="float-2">ƒêO√ÅN</span> <span class="float-3">B52</span>';
        }
        
        // Initialize particles
        particlesJS("particles-js", {
          particles: {
            number: { 
              value: 120,
              density: {
                enable: true,
                value_area: 800
              }
            },
            color: { 
              value: ["#00ffff", "#00aaff", "#0088ff", "#ffffff"] 
            },
            shape: { 
              type: "circle",
              stroke: {
                width: 0,
                color: "#000000"
              }
            },
            opacity: {
              value: 0.7,
              random: true,
              anim: {
                enable: true,
                speed: 1,
                opacity_min: 0.1,
                sync: false
              }
            },
            size: {
              value: 3,
              random: true,
              anim: {
                enable: true,
                speed: 2,
                size_min: 0.1,
                sync: false
              }
            },
            line_linked: {
              enable: true,
              distance: 150,
              color: "#00aaff",
              opacity: 0.3,
              width: 1
            },
            move: {
              enable: true,
              speed: 1,
              direction: "none",
              random: true,
              straight: false,
              out_mode: "out",
              bounce: false,
              attract: {
                enable: true,
                rotateX: 600,
                rotateY: 1200
              }
            }
          },
          interactivity: {
            detect_on: "canvas",
            events: {
              onhover: {
                enable: true,
                mode: "bubble"
              },
              onclick: {
                enable: true,
                mode: "push"
              },
              resize: true
            },
            modes: {
              bubble: {
                distance: 200,
                size: 6,
                duration: 2,
                opacity: 0.8,
                speed: 3
              },
              push: {
                particles_nb: 4
              }
            }
          },
          retina_detect: true
        });
        
        // Start fetching data
        const apiUrl = game === "hitclub" ? HITCLUB_API : B52_API;
        startFetching(apiUrl, game === "hitclub" ? processHitClubData : processB52Data);
      }
    }

    function deselectGame() {
      currentGame = null;
      gameSelect.style.display = "flex";
      backButton.style.display = "none";
      robot.style.display = "none";
      sunFrame.style.display = "none";
      game789Frame.style.display = "none";
      gameInterface.style.display = "none";

      // D·ª´ng t·∫•t c·∫£ √¢m thanh
      soundWin.pause();
      soundWin.currentTime = 0;
      soundLose.pause();
      soundLose.currentTime = 0;

      // D·ª´ng √¢m thanh t·ª´ iframe Sunwin
      if (sunFrame.contentWindow) {
        try {
          sunFrame.contentWindow.postMessage({type: 'pause-audio'}, '*');
        } catch (e) {
          console.log("Cannot control iframe audio");
        }
      }

      // Reload iframe ƒë·ªÉ d·ª´ng ho√†n to√†n √¢m thanh
      if (sunFrame.src) {
        const currentSrc = sunFrame.src;
        sunFrame.src = 'about:blank';
        setTimeout(() => {
          sunFrame.src = currentSrc;
        }, 100);
      }

      if (game789Frame.src) {
        const currentSrc = game789Frame.src;
        game789Frame.src = 'about:blank';
        setTimeout(() => {
          game789Frame.src = currentSrc;
        }, 100);
      }

      if (fetchInterval) {
        clearInterval(fetchInterval);
        fetchInterval = null;
      }

      if (connectionBackup) {
        clearInterval(connectionBackup);
        connectionBackup = null;
      }

      // Clear analysis timeout
      if (analysisTimeout) {
        clearTimeout(analysisTimeout);
        analysisTimeout = null;
      }

      // Reset t·∫•t c·∫£ tr·∫°ng th√°i
      retryCount = 0;
      currentSessionData = null;
      isAnalyzing = false;
      lastProcessedSession = null;
      lastResultData = null;
      pendingResults = {};

      resetDisplay();
    }

    function resetDisplay() {
      line1.innerHTML = "<strong>Ch·ªù phi√™n m·ªõi</strong>";
      line2.textContent = "";

      // Reset game interface
      phienText.textContent = "#------";
      predictionCircle.textContent = "--";
      extraInfo.textContent = "--";
      statusText.textContent = "‚è≥ S·∫µn s√†ng...";
      clockText.textContent = "--:--:--";
      historyBody.innerHTML = "";

      // Reset error states
      retryCount = 0;
    }

    // Helper functions for game interface
    function playSound(win) {
      const audio = win ? soundWin : soundLose;
      audio.currentTime = 0;
      audio.play().catch(e => console.log("Audio play failed:", e));
    }

    function updateStats() {
      winStats.textContent = `‚úî Th·∫Øng: ${winCount} | ‚úò Thua: ${loseCount}`;
    }

    function formatTime() {
      const now = new Date();
      return now.toLocaleTimeString("vi-VN", {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
    }

    function addHistoryRow(phien, prediction, result, time, isNewResult = false) {
      // Check if this row already exists
      const existingRow = Array.from(historyBody.rows).find(row => 
        row.cells[0].textContent === phien.toString()
      );
      
      const row = document.createElement("tr");
      let evaluation = "<span class='pending'>Ch·ªù k·∫øt qu·∫£</span>";
      
      const predHTML = prediction === "T√†i" 
        ? `<span class="tai-cell">${prediction}</span>` 
        : `<span class="xiu-cell">${prediction}</span>`;
      
      let resultHTML = "<span class='pending'>Ch∆∞a c√≥</span>";
      
      if (result && result !== "Ch∆∞a c√≥" && result.includes("=")) {
        resultHTML = result.includes("T√†i") 
          ? `<span class="tai-cell">${result}</span>` 
          : `<span class="xiu-cell">${result}</span>`;
        
        const win = (prediction === "T√†i" && result.includes("T√†i")) || 
                   (prediction === "X·ªâu" && result.includes("X·ªâu"));
        
        evaluation = win ? "<span class='win'>‚úî Th·∫Øng</span>" : "<span class='lose'>‚úò Thua</span>";
        
        if (isNewResult) {
          win ? winCount++ : loseCount++;
          updateStats();
          playSound(win);
        }
      }
      
      row.innerHTML = `
        <td>${phien}</td>
        <td>${predHTML}</td>
        <td>${resultHTML}</td>
        <td>${evaluation}</td>
        <td>${time}</td>
      `;
      
      if (existingRow) {
        historyBody.replaceChild(row, existingRow);
      } else {
        historyBody.insertBefore(row, historyBody.firstChild);
        if (historyBody.rows.length > 10) historyBody.removeChild(historyBody.lastChild);
      }
    }

    // Data processing
    function processSunData(data) {
      try {
        const session = data.phien || "N/A";
        const prediction = data.du_doan || "Ch∆∞a c√≥";
        const result = data.ket_qua || null;
        
        // Ki·ªÉm tra n·∫øu c√≥ k·∫øt qu·∫£ phi√™n tr∆∞·ªõc
        if (result && currentSessionData && currentSessionData.session < session) {
          showResult(currentSessionData.prediction, result);
          return;
        }
        
        // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu l√† phi√™n m·ªõi ho·∫∑c ch∆∞a c√≥ d·ªØ li·ªáu
        if (!currentSessionData || currentSessionData.session !== session) {
          if (isAnalyzing) return; // ƒêang ph√¢n t√≠ch, kh√¥ng c·∫≠p nh·∫≠t
          
          currentSessionData = {
            session: session,
            prediction: prediction
          };
          
          const predictionClass = prediction === 'T√†i' ? 'tai' : 'xiu';
          line1.innerHTML = `<strong>Phi√™n: #${session + 1}</strong>`;
          line2.innerHTML = `D·ª± ƒëo√°n: <span class="${predictionClass}">${prediction}</span>`;
        }
      } catch (e) {
        console.error("SunWin data error:", e);
        showApiError("L·ªói d·ªØ li·ªáu SunWin");
      }
    }

    function process789Data(data) {
      try {
        if (!data || !data.latestResult) {
          console.log("Invalid 789 data structure:", data);
          return;
        }

        const currentSession = data.latestResult.id_phien;
        const prediction = data.duDoanPattern === "t" ? "T√†i" : "X·ªâu";
        const lastResult = data.latestResult.ket_qua || null;
        const time = formatTime();

        console.log("789 data:", { currentSession, prediction, lastResult });

        // Ki·ªÉm tra v√† x·ª≠ l√Ω k·∫øt qu·∫£ phi√™n tr∆∞·ªõc
        if (lastResult && lastResult.includes("=")) {
          const prevSession = data.latestResult.id_phien - 1;
          
          // T√¨m d·ª± ƒëo√°n t∆∞∆°ng ·ª©ng trong pendingResults
          if (pendingResults[prevSession]) {
            const prevPrediction = pendingResults[prevSession];
            
            // C·∫≠p nh·∫≠t k·∫øt qu·∫£ trong b·∫£ng l·ªãch s·ª≠
            updateHistoryWithResult(prevSession, prevPrediction, lastResult, time);
            
            // X√≥a kh·ªèi pending
            delete pendingResults[prevSession];
          }
        }

        // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu l√† phi√™n m·ªõi v√† kh√¥ng ƒëang ph√¢n t√≠ch
        if (currentSession !== lastProcessedSession && !isAnalyzing) {
          lastProcessedSession = currentSession;
          currentSessionData = {
            session: currentSession,
            prediction: prediction
          };
          
          // L∆∞u d·ª± ƒëo√°n v√†o pending
          pendingResults[currentSession] = prediction;
          
          // Update robot interface
          line1.innerHTML = `<strong>Phi√™n: #${currentSession}</strong>`;
          line2.innerHTML = `D·ª± ƒëo√°n: <span class="${prediction === 'T√†i' ? 'tai' : 'xiu'}">${prediction}</span>`;
        }

      } catch (e) {
        console.error("789 data error:", e);
      }
    }

    function processHitClubData(data) {
      try {
        if (!data || !data.phien_ke_tiep || !data.du_doan) {
          console.log("Invalid HitClub data structure:", data);
          return;
        }

        const currentSession = data.phien_ke_tiep.sid;
        const prediction = data.du_doan;
        const lastResult = data.phien_truoc ? data.phien_truoc.ket_qua : null;
        const time = formatTime();

        console.log("HitClub data:", { currentSession, prediction, lastResult });

        // Ki·ªÉm tra v√† x·ª≠ l√Ω k·∫øt qu·∫£ phi√™n tr∆∞·ªõc
        if (lastResult && lastResult.includes("=") && data.phien_truoc) {
          const prevSession = data.phien_truoc.sid;
          
          // T√¨m d·ª± ƒëo√°n t∆∞∆°ng ·ª©ng trong pendingResults
          if (pendingResults[prevSession]) {
            const prevPrediction = pendingResults[prevSession];
            
            // C·∫≠p nh·∫≠t k·∫øt qu·∫£ trong b·∫£ng l·ªãch s·ª≠
            updateHistoryWithResult(prevSession, prevPrediction, lastResult, time);
            
            // X√≥a kh·ªèi pending
            delete pendingResults[prevSession];
          }
        }

        // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu l√† phi√™n m·ªõi v√† kh√¥ng ƒëang ph√¢n t√≠ch
        if (currentSession !== lastProcessedSession && !isAnalyzing) {
          lastProcessedSession = currentSession;
          currentSessionData = {
            session: currentSession,
            prediction: prediction
          };
          
          // L∆∞u d·ª± ƒëo√°n v√†o pending
          pendingResults[currentSession] = prediction;
          
          // Update game interface safely
          if (phienText) phienText.textContent = `#${currentSession}`;
          if (predictionCircle) {
            predictionCircle.innerHTML = prediction === "T√†i" 
              ? `<span style="color:#00ff00; text-shadow: 0 0 15px #00ff00;">T√ÄI</span>` 
              : `<span style="color:#ff4444; text-shadow: 0 0 15px #ff4444;">X·ªàU</span>`;
          }
          if (extraInfo) {
            extraInfo.innerHTML = `üìà M·∫´u: <strong>${data.pattern || 'N/A'}</strong> | üïê Th·ªùi gian: <strong>${data.time || 'N/A'}</strong>`;
          }
          if (statusText) {
            statusText.innerHTML = '<span style="color:#00ff00">‚óè</span> HITCLUB ƒê√É K·∫æT N·ªêI';
          }
          if (clockText) clockText.textContent = time;

          // Add current prediction to history with pending status
          addHistoryRow(currentSession, prediction, "Ch∆∞a c√≥", time);
        }

      } catch (e) {
        console.error("HitClub data error:", e);
      }
    }

    function processB52Data(data) {
      try {
        if (!data || !data.sid || !data.du_doan) {
          console.log("Invalid B52 data structure:", data);
          return;
        }

        const currentSession = data.sid_tiep_theo || data.sid + 1;
        const prediction = data.du_doan;
        const lastResult = data.ket_qua;
        const time = formatTime();

        console.log("B52 data:", { currentSession, prediction, lastResult, sid: data.sid });

        // Ki·ªÉm tra v√† x·ª≠ l√Ω k·∫øt qu·∫£ phi√™n hi·ªán t·∫°i
        if (lastResult && lastResult.includes("=")) {
          const currentSessionWithResult = data.sid;
          
          // T√¨m d·ª± ƒëo√°n t∆∞∆°ng ·ª©ng trong pendingResults
          if (pendingResults[currentSessionWithResult]) {
            const prevPrediction = pendingResults[currentSessionWithResult];
            
            // C·∫≠p nh·∫≠t k·∫øt qu·∫£ trong b·∫£ng l·ªãch s·ª≠
            updateHistoryWithResult(currentSessionWithResult, prevPrediction, lastResult, time);
            
            // X√≥a kh·ªèi pending
            delete pendingResults[currentSessionWithResult];
          }
        }

        // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu l√† phi√™n m·ªõi v√† kh√¥ng ƒëang ph√¢n t√≠ch
        if (currentSession !== lastProcessedSession && !isAnalyzing) {
          lastProcessedSession = currentSession;
          currentSessionData = {
            session: currentSession,
            prediction: prediction
          };
          
          // L∆∞u d·ª± ƒëo√°n v√†o pending
          pendingResults[currentSession] = prediction;
          
          // Update game interface safely
          if (phienText) phienText.textContent = `#${currentSession}`;
          if (predictionCircle) {
            predictionCircle.innerHTML = prediction === "T√†i" 
              ? `<span style="color:#00ff00; text-shadow: 0 0 15px #00ff00;">T√ÄI</span>` 
              : `<span style="color:#ff4444; text-shadow: 0 0 15px #ff4444;">X·ªàU</span>`;
          }
          if (extraInfo) {
            extraInfo.innerHTML = `üìà M·∫´u: <strong>${data.pattern || 'N/A'}</strong> | üìä Phi√™n Tr∆∞·ªõc: <strong>#${data.sid}</strong>`;
          }
          if (statusText) {
            statusText.innerHTML = '<span style="color:#00ff00">‚óè</span> B52 ƒê√É K·∫æT N·ªêI';
          }
          if (clockText) clockText.textContent = time;

          // Add current prediction to history with pending status
          addHistoryRow(currentSession, prediction, "Ch∆∞a c√≥", time);
        }

      } catch (e) {
        console.error("B52 data error:", e);
      }
    }

    function updateHistoryWithResult(session, prediction, result, time) {
      // T√¨m v√† c·∫≠p nh·∫≠t row trong b·∫£ng l·ªãch s·ª≠
      const existingRow = Array.from(historyBody.rows).find(row => 
        row.cells[0].textContent === session.toString()
      );
      
      if (existingRow) {
        const win = (prediction === "T√†i" && result.includes("T√†i")) || 
                   (prediction === "X·ªâu" && result.includes("X·ªâu"));
        
        const resultHTML = result.includes("T√†i") 
          ? `<span class="tai-cell">${result}</span>` 
          : `<span class="xiu-cell">${result}</span>`;
        
        const evaluation = win ? "<span class='win'>‚úî Th·∫Øng</span>" : "<span class='lose'>‚úò Thua</span>";
        
        // C·∫≠p nh·∫≠t c·ªôt k·∫øt qu·∫£ v√† ƒë√°nh gi√°
        existingRow.cells[2].innerHTML = resultHTML;
        existingRow.cells[3].innerHTML = evaluation;
        
        // C·∫≠p nh·∫≠t th·ªëng k√™
        win ? winCount++ : loseCount++;
        updateStats();
        playSound(win);
      }
    }

    function showResult(prediction, actualResult) {
      if (isAnalyzing) return;
      
      // X√°c ƒë·ªãnh k·∫øt qu·∫£ th·∫Øng/thua
      const isWin = (prediction === "T√†i" && actualResult.includes("T√†i")) || 
                   (prediction === "X·ªâu" && actualResult.includes("X·ªâu"));
      
      // Hi·ªÉn th·ªã k·∫øt qu·∫£ (5 gi√¢y)
      if (currentGame === "sun" || currentGame === "game789") {
        line1.innerHTML = `<strong>K·∫øt qu·∫£: ${actualResult}</strong>`;
        line2.innerHTML = isWin ? 
          `<span style="color: #00ff00; font-weight: bold;">üéâ CHI·∫æN TH·∫ÆNG!</span>` :
          `<span style="color: #ff4444; font-weight: bold;">üôÅ THUA CU·ªòC!</span>`;
      } else {
        predictionCircle.innerHTML = isWin ? 
          `<span style="color:#00ff00; text-shadow: 0 0 15px #00ff00;">TH·∫ÆNG</span>` :
          `<span style="color:#ff4444; text-shadow: 0 0 15px #ff4444;">THUA</span>`;
        statusText.innerHTML = `<span style="color:${isWin ? '#00ff00' : '#ff4444'}">‚óè ${isWin ? 'CHI·∫æN TH·∫ÆNG' : 'THUA CU·ªòC'}</span>`;
      }
      
      // Ph√°t √¢m thanh
      playSound(isWin);
      
      // Sau 5 gi√¢y, hi·ªÉn th·ªã "ƒêang ph√¢n t√≠ch..."
      setTimeout(() => {
        showAnalyzing();
      }, 5000);
    }
    
    function showAnalyzing() {
      isAnalyzing = true;
      
      if (currentGame === "sun" || currentGame === "game789") {
        line1.innerHTML = `<strong>üîç ƒêang ph√¢n t√≠ch...</strong>`;
        line2.innerHTML = `<span style="color: #ffaa00;">Vui l√≤ng ch·ªù d·ª± ƒëo√°n m·ªõi</span>`;
      } else {
        predictionCircle.innerHTML = `<span style="color:#ffaa00; text-shadow: 0 0 15px #ffaa00;">...</span>`;
        statusText.innerHTML = `<span style="color:#ffaa00">üîç ƒêANG PH√ÇN T√çCH</span>`;
      }
      
      // Sau 5 gi√¢y ph√¢n t√≠ch, cho ph√©p c·∫≠p nh·∫≠t d·ª± ƒëo√°n m·ªõi
      analysisTimeout = setTimeout(() => {
        isAnalyzing = false;
        currentSessionData = null; // Reset ƒë·ªÉ nh·∫≠n d·ª± ƒëo√°n m·ªõi
      }, 5000);
    }

    function showApiError(message = "L·ªói k·∫øt n·ªëi API") {
      // Kh√¥ng hi·ªÉn th·ªã th√¥ng b√°o l·ªói phi·ªÅn nhi·ªÖu
      // Ch·ªâ ghi log trong console
      console.log("API connection issue:", message);
    }

    // Enhanced connection with multiple fallback APIs and immediate retry
    const B52_BACKUP_APIS = [
      "https://xaoko-19272.onrender.com/taixiu",
      B52_API,
      "https://cors-anywhere.herokuapp.com/" + B52_API,
      "https://api.codetabs.com/v1/proxy/?quest=" + encodeURIComponent(B52_API)
    ];

    const GAME789_BACKUP_APIS = [
      "https://tailkoa-762.onrender.com/taixiu",
      "https://api.codetabs.com/v1/proxy/?quest=https://tailkoa-762.onrender.com/taixiu",
      "https://cors-anywhere.herokuapp.com/https://tailkoa-762.onrender.com/taixiu"
    ];

    let currentB52ApiIndex = 0;
    let current789ApiIndex = 0;
    let fetchAttempts = 0;
    let connectionPrimary = null;
    let connectionBackup = null;

    // Primary proxy for all requests
    const PRIMARY_PROXY = "https://api.codetabs.com/v1/proxy/?quest=";

    // Enhanced fetch with multiple strategies  
    async function fetchDataEnhanced(url, processor, isBackup = false) {
      // Strategy 1: Try CORS proxy first (most reliable)
      const success = await fetchWithProxy(url, processor, isBackup);
      if (success) return true;

      // Strategy 2: Try direct fetch if proxy fails
      return await fetchDirect(url, processor, isBackup);
    }

    // Direct fetch attempt
    async function fetchDirect(url, processor, isBackup = false) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      
      try {
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Cache-Control': 'no-cache',
            'Origin': window.location.origin
          },
          signal: controller.signal,
          mode: 'cors'
        });

        clearTimeout(timeoutId);

        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const data = await response.json();
        processor(data);
        retryCount = 0;
        fetchAttempts = 0;
        return true;

      } catch (error) {
        clearTimeout(timeoutId);
        console.log(`Direct fetch failed: ${error.message}`);
        return false;
      }
    }

    // Simplified proxy fetch
    async function fetchWithProxy(originalUrl, processor, isBackup = false) {
      const proxyUrl = PRIMARY_PROXY + encodeURIComponent(originalUrl);
      
      try {
        console.log(`Fetching ${originalUrl} via proxy...`);
        
        const response = await fetch(proxyUrl, {
          method: 'GET',
          headers: {
            'Accept': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`Proxy error: ${response.status}`);
        }

        const data = await response.json();
        console.log(`‚úì Data received successfully:`, data);
        
        processor(data);
        retryCount = 0;
        fetchAttempts = 0;
        return true;

      } catch (error) {
        console.error(`‚úó Proxy failed:`, error.message);
        return false;
      }
    }

    // Main connection function with proper error handling
    async function fetchWithParallelConnections(processor) {
      if (isFetching) return;
      isFetching = true;

      try {
        let primaryUrl;
        let backupApis;
        
        if (currentGame === 'b52') {
          primaryUrl = B52_API;
          backupApis = B52_BACKUP_APIS;
        } else if (currentGame === 'game789') {
          primaryUrl = GAME789_API;
          backupApis = GAME789_BACKUP_APIS;
        } else if (currentGame === 'hitclub') {
          primaryUrl = HITCLUB_API;
        } else {
          primaryUrl = SUNWIN_API;
        }
        
        console.log(`=== Connecting to ${currentGame.toUpperCase()} ===`);
        
        const success = await fetchDataEnhanced(primaryUrl, processor, false);
        
        if (success) {
          console.log(`‚úì ${currentGame.toUpperCase()} connected successfully`);
          if (statusText && currentGame !== 'sun' && currentGame !== 'game789') {
            statusText.innerHTML = '<span style="color:#00ff00">‚óè</span> K·∫æT N·ªêI TH√ÄNH C√îNG';
          }
        } else {
          console.log(`‚úó ${currentGame.toUpperCase()} connection failed`);
          
          // Try backup APIs if available
          if (backupApis && backupApis.length > 0) {
            let backupSuccess = false;
            for (let i = 0; i < backupApis.length; i++) {
              backupSuccess = await fetchDataEnhanced(backupApis[i], processor, true);
              if (backupSuccess) break;
            }
            
            if (!backupSuccess) {
              console.log(`All backup APIs failed for ${currentGame}`);
              if (statusText && currentGame !== 'sun' && currentGame !== 'game789') {
                statusText.innerHTML = '<span style="color:#ff4444">‚óè</span> K·∫æT N·ªêI TH·∫§T B·∫†I - TH·ª¨ L·∫†I...';
              }
            }
          }
        }

      } catch (error) {
        console.error("Connection error:", error.message);
        if (statusText && currentGame !== 'sun' && currentGame !== 'game789') {
          statusText.innerHTML = '<span style="color:#ff4444">‚óè</span> L·ªñI K·∫æT N·ªêI';
        }
      } finally {
        isFetching = false;
      }
    }

    function startFetching(url, processor) {
      console.log(`Starting fetching for ${currentGame}`);
      
      // Clear any existing intervals
      if (fetchInterval) clearInterval(fetchInterval);
      if (connectionBackup) clearInterval(connectionBackup);
      
      // Initial immediate fetch
      fetchWithParallelConnections(processor).catch(error => {
        console.error("Initial fetch error:", error);
      });
      
      // Set up regular interval
      const interval = currentGame === 'b52' ? 3000 : 5000; // 3s for B52, 5s for others
      
      fetchInterval = setInterval(() => {
        fetchWithParallelConnections(processor).catch(error => {
          console.error("Interval fetch error:", error);
        });
      }, interval);
    }

    // Connection maintenance - simplified
    function maintainConnection() {
      if (currentGame && !isFetching) {
        console.log(`Maintaining connection for ${currentGame}`);
      }
    }

    // Start connection maintenance
    setInterval(maintainConnection, 10000);

    // Update clock every second
    setInterval(() => {
      if (gameInterface.style.display === "block") {
        clockText.textContent = formatTime();
      }
    }, 1000);

    // Drag and drop for robot
    let isDragging = false;
    let offsetX = 0;
    let offsetY = 0;

    robot.addEventListener("mousedown", (e) => {
      isDragging = true;
      offsetX = e.clientX - robot.offsetLeft;
      offsetY = e.clientY - robot.offsetTop;
    });

    document.addEventListener("mousemove", (e) => {
      if (isDragging) {
        robot.style.left = e.clientX - offsetX + "px";
        robot.style.top = e.clientY - offsetY + "px";
      }
    });

    document.addEventListener("mouseup", () => {
      isDragging = false;
    });

    robot.addEventListener("touchstart", (e) => {
      isDragging = true;
      const touch = e.touches[0];
      offsetX = touch.clientX - robot.offsetLeft;
      offsetY = touch.clientY - robot.offsetTop;
    });

    document.addEventListener("touchmove", (e) => {
      if (isDragging) {
        const touch = e.touches[0];
        robot.style.left = touch.clientX - offsetX + "px";
        robot.style.top = touch.clientY - offsetY + "px";
      }
    });

    document.addEventListener("touchend", () => {
      isDragging = false;
    });

    // Auto-hide back button
    let hideTimeout;
    document.addEventListener("mousemove", () => {
      backButton.style.opacity = "1";
      clearTimeout(hideTimeout);
      hideTimeout = setTimeout(() => {
        backButton.style.opacity = "0.7";
      }, 2000);
    });
  </script>
</body>
</html>  border-radius:10px;
  border:none;
  outline:none;
  font-size:16px;
  text-align:center;
}
#keyBtn{
  margin-top:15px;
  width:100%;
  padding:12px;
  border-radius:10px;
  border:none;
  font-weight:bold;
  cursor:pointer;
  background:linear-gradient(135deg,#00ffff,#0088ff);
}
#keyMsg{
  margin-top:10px;
  font-size:14px;
  min-height:18px;
}
@keyframes shake{
  0%{transform:translateX(0)}
  25%{transform:translateX(-5px)}
  50%{transform:translateX(5px)}
  75%{transform:translateX(-5px)}
  100%{transform:translateX(0)}
}
@keyframes fadeIn{
  from{opacity:0;transform:scale(.9)}
  to{opacity:1;transform:scale(1)}
}
/* ================= END KEY POPUP ================= */

/* ====== PH·∫¶N CSS G·ªêC C·ª¶A B·∫†N (GI·ªÆ NGUY√äN) ====== */
/* (v√¨ qu√° d√†i n√™n b·∫°n gi·ªØ nguy√™n CSS g·ªëc ·ªü ƒë√¢y, 
   KH√îNG c·∫ßn s·ª≠a g√¨ th√™m) */
</style>
</head>

<body>

<!-- ================= KEY POPUP ================= -->
<div id="keyOverlay">
  <div id="keyBox">
    <h3>üîê Nh·∫≠p Key Truy C·∫≠p</h3>
    <input id="keyInput" type="password" placeholder="Nh·∫≠p key..." />
    <button id="keyBtn">X√°c nh·∫≠n</button>
    <div id="keyMsg"></div>
  </div>
</div>
<!-- ================= END KEY POPUP ================= -->

<!-- ====== PH·∫¶N HTML G·ªêC C·ª¶A B·∫†N (gameSelect, iframe, robot...) ====== -->
<!-- üëâ GI·ªÆ NGUY√äN TO√ÄN B·ªò HTML G·ªêC ·ªû ƒê√ÇY -->


<script>
/* ================= KEY SYSTEM ================= */
const KEY_HASH =
"a9b7e9b6d5d1c7c0b0c4e9f2c1c6c6d61b3f4f8b7c5c9f3e5e6d9a3c4b2a1";

const keyOverlay = document.getElementById("keyOverlay");
const keyInput   = document.getElementById("keyInput");
const keyBtn     = document.getElementById("keyBtn");
const keyMsg     = document.getElementById("keyMsg");

let failCount = 0;

// ·∫®n trang ch√≠nh ban ƒë·∫ßu
document.getElementById("gameSelect").style.display = "none";

// N·∫øu ƒë√£ x√°c th·ª±c tr∆∞·ªõc ƒë√≥
if(localStorage.getItem("access_granted")==="1"){
  keyOverlay.style.display="none";
  document.getElementById("gameSelect").style.display="flex";
}

keyBtn.onclick = checkKey;
keyInput.onkeydown = e => { if(e.key==="Enter") checkKey(); };

async function sha256(text){
  const data = new TextEncoder().encode(text);
  const hash = await crypto.subtle.digest("SHA-256", data);
  return Array.from(new Uint8Array(hash))
    .map(b=>b.toString(16).padStart(2,"0")).join("");
}

async function checkKey(){
  const input = keyInput.value.trim();
  const hash  = await sha256(input);

  if(hash === KEY_HASH){
    localStorage.setItem("access_granted","1");
    keyMsg.style.color="#00ff99";
    keyMsg.textContent="‚úî X√°c th·ª±c th√†nh c√¥ng";
    setTimeout(()=>{
      keyOverlay.style.display="none";
      document.getElementById("gameSelect").style.display="flex";
    },500);
  }else{
    failAttempt();
  }
}

function failAttempt(){
  failCount++;
  keyMsg.style.color="#ff6666";
  keyMsg.textContent=`‚ùå Sai key (${failCount}/5)`;
  keyOverlay.style.animation="shake .4s";
  setTimeout(()=>keyOverlay.style.animation="",400);

  if(failCount>=5){
    keyMsg.textContent="‚õî B·ªã kh√≥a 30 gi√¢y";
    keyInput.disabled=true;
    keyBtn.disabled=true;
    setTimeout(()=>{
      failCount=0;
      keyInput.disabled=false;
      keyBtn.disabled=false;
      keyMsg.textContent="";
    },30000);
  }
}
/* ================= END KEY SYSTEM ================= */

/* ====== PH·∫¶N JAVASCRIPT G·ªêC C·ª¶A B·∫†N ====== */
/* üëâ D√ÅN NGUY√äN TO√ÄN B·ªò SCRIPT BOT T√ÄI X·ªàU ·ªû ƒê√ÇY */
</script>

</body>
</html>
